<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 3.0//EN">
<!--Converted with LaTeX2HTML 96.1-f (May 31, 1996) by Nikos Drakos (nikos@cbl.leeds.ac.uk), CBLU, University of Leeds -->
<HTML>
<HEAD>
<TITLE>Technical Issues</TITLE>
<META NAME="description" CONTENT="Technical Issues">
<META NAME="keywords" CONTENT="tm2">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<LINK REL=STYLESHEET HREF="tm2.css">
</HEAD>
<BODY LANG="EN">
 <A NAME="tex2html2" HREF="http://tecfa.unige.ch//moo/book2/tm2.html"> <IMG  ALIGN=BOTTOM ALT="external" SRC="http://tecfa.unige.ch/ico/navi/tex2html/top.gif"  > </A> <A NAME="tex2html1460" HREF="node63.html"><IMG WIDTH=37 HEIGHT=24 ALIGN=BOTTOM ALT="next" SRC="http://tecfa.unige.ch/gif/tex2html//next_motif.gif"></A> <A NAME="tex2html1458" HREF="node61.html"><IMG WIDTH=26 HEIGHT=24 ALIGN=BOTTOM ALT="up" SRC="http://tecfa.unige.ch/gif/tex2html//up_motif.gif"></A> <A NAME="tex2html1452" HREF="node61.html"><IMG WIDTH=63 HEIGHT=24 ALIGN=BOTTOM ALT="previous" SRC="http://tecfa.unige.ch/gif/tex2html//previous_motif.gif"></A> <A NAME="tex2html1462" HREF="node1.html"><IMG WIDTH=65 HEIGHT=24 ALIGN=BOTTOM ALT="contents" SRC="http://tecfa.unige.ch/gif/tex2html//contents_motif.gif"></A> <A NAME="tex2html1463" HREF="node167.html"><IMG WIDTH=43 HEIGHT=24 ALIGN=BOTTOM ALT="index" SRC="http://tecfa.unige.ch/gif/tex2html//index_motif.gif"></A><BR>
<B> Next:</B> <A NAME="tex2html1461" HREF="node63.html">Conceptual Issues</A>
<B>Up:</B> <A NAME="tex2html1459" HREF="node61.html">6.3 Ken's Turing Robot</A>
<B> Previous:</B> <A NAME="tex2html1453" HREF="node61.html">6.3 Ken's Turing Robot</A>
<BR> <P>
<H2><A NAME="SECTION03331000000000000000">Technical Issues</A></H2>
<P>
<A NAME="sectechnicaleliza">&#160;</A>
<P>
Programming a fully functional Eliza Robot is not easy, but it should
not be too hard to produce a nice ``doll'' once you (a) grasped the way
Ken's Bot work, (b) you learned how to write simple regular expressions
and (c) you played around with some Eliza Bots or read some texts about them.
<P>
<H3><A NAME="SECTION03331100000000000000">Basic operation</A></H3>
<P>
<A NAME="secbotops">&#160;</A>
<P>
This is a slightly edited version from 
<A NAME="tex2html102" HREF="http://tecfamoo.unige.ch:7778/1684">'help bot'</A>.<A NAME="tex2html103" HREF="http://tecfa.unige.ch/moo/book2//footnode.html#636"><IMG  ALIGN=BOTTOM ALT="gif" SRC="http://tecfa.unige.ch/gif/tex2html//foot_motif.gif"></A>
<P>
<H4><A NAME="SECTION03331110000000000000">Adding A Word For Your Bot To Respond To:</A></H4>
<P>
   To see what words your bot already responds to type <code>'seewords botname'</code>.
   To teach your bot to respond to 'donut' with either 'I like donuts too.' or
  'Donuts are very tasty!' just type '@addword botname' and enter the keyword
  'donut'.  Then enter the appropriate responses a line at a time.  End with
   a single period on a line by itself.
<P>
   Don't try to build a large list of simple word matching patterns, but rather
study how to work with patterns
<P>
<H4><A NAME="SECTION03331120000000000000">Adding a Pattern FOR YOUR BOT TO RESPOND TO:</A></H4>
<P>
   Suppose you wished your bot to hear something like
<SMALL CLASS=SMALL><PRE>       MY DONUT ISN'T VERY TASTY
   and respond with 
       WHAT'S SO GREAT ABOUT A TASTY DONUT?
   To do this you must teach your bot to respond to the pattern 
       MY a ISN'T VERY b.</PRE></SMALL>
   To understand what patterns look like, type <code>'seepat botname'</code> and study the
   examples. For additional assistance on understanding the syntax of patterns
   see the next section <A HREF="node62.html#secregexps">6.3.1</A>.
 When you think you are ready to add a pattern type 
<SMALL CLASS=SMALL><PRE>  @addpat botname' and enter the following line when asked to do so: 
       my %(%w*%) isn't very %(.*%)
   Then type in the response form:
       What's so great about a %2 %1?</PRE></SMALL>
   Add as many response forms as you wish on separate lines.  End with a 
   period on a single line.
<P>
<H4><A NAME="SECTION03331130000000000000">Adding random Responses:</A></H4>
<P>
   These responses are triggered whenever your bot can't find a keyword, a 
   pattern, or a question. To see the responses already programmed type:<BR> 
   <code>'seerandoms botname'</code>.<BR> To add a new random response type:<BR> 
   <code>'addrandom botname'</code> and enter a new response.
<P>
<H4><A NAME="SECTION03331140000000000000">Adding a Random RESPONSE TO A QUESTION:</A></H4>
<P>
   When your bot senses a question is being asked it responds with a random
   'answer'.  To see the random question responses already programmed into
   your bot type <code>'seequestionresponses botname'</code>.  To add a new response
   type  <code>'addquestionresponse botname'</code>.
<P>
<H4><A NAME="SECTION03331150000000000000">Removing and moving patterns</A></H4>
<P>
<UL>
<LI> To remove words, patterns, random responses or answers use the
  appropriate 'rm-' command.  For example, to remove pattern number 5
  on your bot just type 'rmpat 5 from bot'.
<LI> Your bot responds to patterns in the order in which it matches
  them. If you wish to move pattern number 7 to a position nearer the
  beginning of the list you might type something like 
  <code>'mvpat 7 on botname'</code>. 
  You will then be asked to enter a line number to move
  pattern to.
 </UL>
<P>
Caution: This bot was designed for serious educational and experimental
   purposes.  It makes an excellent 'guide' or 'tutor' and is an interesting
   vehicle for the study of the limits of language understanding using an
   'Eliza' approach.  BUT.. it has great spam potential since it responds to
   nearly everything it hears.  'Hush botname' when not needed and please be
   considerate of others around you ..
<P>
Finally, as <em>always</em> ``<code>@examine &lt;bot&gt;</code>'' to see the full list
of verbs !
<P>
<H3><A NAME="SECTION03331200000000000000">Regular Expressions</A></H3>
<P>
<A NAME="secregexps">&#160;</A>
<A NAME=650>&#160;</A>
<A NAME=651>&#160;</A>
<P>
Ken's Turing Bot works with regular expressions as mentionned above. It
is probably best to learn by example and then try out more complex patterns
by learning how to use regular expressions.
<P>
Regular expressions are similar in most programming languages and fancy
editors:
<UL>
<LI> In the MOO: <A NAME="tex2html106" HREF="http://tecfamoo.unige.ch:7777/help/?help_topic=regular">'help regular'</A> and
<A NAME="tex2html107" HREF="http://tecfa.unige.ch/guides/MOO/ProgMan/ProgrammersManual_44.html#IDX40">MOO Prog Man section</A>
<LI> 
<A NAME="tex2html108" HREF="http://tecfa.unige.ch/cgi-bin/info2www?(xemacs.info)Regexps">In Emacs</A>
<LI> 
<A NAME="tex2html109" HREF="http://tecfa.unige.ch/cgi-bin/man-cgi?perlre">In the Perl language</A>
<LI> In various UNIX tools, e.g.
<A NAME="tex2html110" HREF="http://tecfa.unige.ch/cgi-bin/man-cgi?ed">ed</A>,
<A NAME="tex2html111" HREF="http://tecfa.unige.ch/cgi-bin/man-cgi?grep">grep</A> and
<A NAME="tex2html112" HREF="http://tecfa.unige.ch/cgi-bin/man-cgi?egrep">egrep</A>
<P>
</UL>
<P>
So, building a nice Turing bot is a good exercise for learning regexps
which come very handy when you write Perl scripts or if you want to
do fancy text processing with an editor. Here is the complete syntax for
regular expressions:
<P>
Regular expression matching allows you to test whether a string fits
into a specific syntactic shape.  You can also search a string for a
substring that fits a pattern.  See also the built-in function
match()/rmatch().
<P>
A regular expression describes a set of strings.  The simplest case is
one that describes a particular string; for example, the string
<code>`foo'</code> when regarded as a regular expression matches
<code>`foo'</code> and nothing else.  Nontrivial regular expressions use
certain special constructs so that they can match more than one
string.  For example, the regular expression <code>`foo%|bar'</code> matches
either the string <code>`foo'</code> or the string <code>`bar'</code>; the regular
expression <code>`c[ad]*r'</code> matches any of the strings <code>`cr'</code>,
<code>`car'</code>, <code>`cdr'</code>, <code>`caar'</code>, <code>`cadddar'</code> and all
other such strings with any number of <code>`a'</code>'s and <code>`d'</code>'s.
<P>
Regular expressions have a syntax in which a few characters are
special constructs and the rest are &quot;ordinary&quot;.  An ordinary character
is a simple regular expression that matches that character and nothing
else.  The special characters are <code>`$'</code>, <code>`^'</code>, <code>`.'</code>,
<code>`*'</code>, <code>`+'</code>, <code>`?'</code>, <code>`['</code>, <code>`]'</code> and
<code>`%'</code>.  Any other character appearing in a regular expression is
ordinary, unless a <code>`%'</code> precedes it.
<P>
For example, <code>`f'</code> is not a special character, so it is ordinary,
and therefore <code>`f'</code> is a regular expression that matches the
string <code>`f'</code> and no other string.  (It does *not*, for example,
match the string <code>`ff'</code>.)  Likewise, <code>`o'</code> is a regular
expression that matches only <code>`o'</code>.
<P>
Any two regular expressions A and B can be concatenated.  The result
is a regular expression which matches a string if A matches some
amount of the beginning of that string and B matches the rest of the
string.
<P>
As a simple example, we can concatenate the regular expressions
<code>`f'</code> and <code>`o'</code> to get the regular expression <code>`fo'</code>,
which matches only the string <code>`fo'</code>.  Still trivial.
<P>
The following are the characters and character sequences that have
special meaning within regular expressions.  Any character not
mentioned here is not special; it stands for exactly itself for the
purposes of searching and matching.
<P>
<DL ><DT><STRONG>`.'</STRONG>
<DD> is a special character that matches any single
  character.  Using concatenation, we can make regular expressions
  like <code>`a.b'</code>, which matches any three-character string that
  begins with <code>`a'</code> and ends with <code>`b'</code>.
<P>
<DT><STRONG>`*'</STRONG>
<DD> is not a construct by itself; it is a suffix that
  means that the preceding regular expression is to be repeated as
  many times as possible.  In <code>`fo*'</code>, the <code>`*'</code> applies to
  the <code>`o'</code>, so <code>`fo*'</code> matches <code>`f'</code> followed by any
  number of <code>`o'</code>'s.
<P>
  The case of zero <code>`o'</code>'s is allowed: <code>`fo*'</code> does match
  <code>`f'</code>.
<P>
  <code>`*'</code> always applies to the *smallest* possible preceding
  expression.  Thus, <code>`fo*'</code> has a repeating <code>`o'</code>, not a
  repeating <code>`fo'</code>.
<P>
  The matcher processes a <code>`*'</code> construct by matching,
  immediately, as many repetitions as can be found.  Then it continues
  with the rest of the pattern.  If that fails, it backtracks,
  discarding some of the matches of the <code>`*'</code>'d construct in
  case that makes it possible to match the rest of the pattern.  For
  example, matching <code>`c[ad]*ar'</code> against the string
  <code>`caddaar'</code>, the <code>`[ad]*'</code> first matches <code>`addaa'</code>,
  but this does not allow the next <code>`a'</code> in the pattern to match.
  So the last of the matches of <code>`[ad]'</code> is undone and the
  following <code>`a'</code> is tried again.  Now it succeeds.
<P>
Let's have a look at an example from Ken's Bot:
<SMALL CLASS=SMALL><PRE>   it's %(.*%)</PRE></SMALL>
The <code>.*</code> will match any chain of characters. E.g. this pattern would
match something like:
<SMALL CLASS=SMALL><PRE>   it's time now
   it's spring</PRE></SMALL>
but it would not match something like:
<SMALL CLASS=SMALL><PRE>   I tell you it's time now</PRE></SMALL>
a pattern like this would:
<SMALL CLASS=SMALL><PRE>   .* it's .*</PRE></SMALL>
See below for what the <code>%(.. %)</code> expression does in addition.
<P>
<DT><STRONG>`+'</STRONG>
<DD> is like <code>`*'</code> except that at least one match
  for the preceding pattern is required for <code>`+'</code>.  Thus,
  <code>`c[ad]</code>r'+ does not match <code>`cr'</code> but does match anything
  else that <code>`c[ad]*r'</code> would match.
<P>
<DT><STRONG>`?'</STRONG>
<DD> is like <code>`*'</code> except that it allows either zero
  or one match for the preceding pattern.  Thus, <code>`c[ad]?r'</code>
  matches <code>`cr'</code> or <code>`car'</code> or <code>`cdr'</code>, and nothing
  else.
<P>
<DT><STRONG>character set:</STRONG>
<DD> <code>`[... ]'</code><BR> <code>`['</code> begins a &quot;character set&quot;, which is
  terminated by a <code>`]'</code>.  In the simplest case, the characters
  between the two brackets form the set.  Thus, <code>`[ad]'</code> matches
  either <code>`a'</code> or <code>`d'</code>, and <code>`[ad]*'</code> matches any
  string of <code>`a'</code>'s and <code>`d'</code>'s (including the empty
  string), from which it follows that <code>`c[ad]*r'</code> matches
  <code>`car'</code>, etc.
<P>
  Character ranges can also be included in a character set, by writing
  two characters with a <code>`-'</code> between them.  Thus, <code>`[a-z]'</code>
  matches any lower-case letter.  Ranges may be intermixed freely with
  individual characters, as in
<code>`[a-z$%.]'</code>, which matches any lower case letter or
<code>`$'</code>, <code>`%'</code> or period.
<P>
Note that the usual special characters are not special any more inside
a character set.  A completely different set of special characters
exists inside character sets: <code>`]'</code>, <code>`-'</code> and <code>`^'</code>.
<P>
To include a <code>`]'</code> in a character set, you must make it the first
character.  For example, <code>`[]a]'</code> matches <code>`]'</code> or
<code>`a'</code>.  To include a <code>`-'</code>, you must use it in a context
where it cannot possibly indicate a range: that is, as the first
character, or immediately after a range.
<P>
<DT><STRONG>character exclusion:</STRONG>
<DD>`<code>[^ ... ]</code>'<BR> 
 <code>`[^'</code> begins a &quot;complement character
  set&quot;, which matches any character except the ones specified.  Thus,
  <code>`[^a-z0-9A-Z]'</code> matches all characters *except* letters and
  digits.
<P>
  <code>`^'</code> is not special in a character set unless it is the first
  character.  The character following the <code>`^'</code> is treated as if
  it were first (it may be a <code>`-'</code> or a <code>`]'</code>).
<P>
  <code>`^'</code> is a special character that matches the empty string -
  but only if at the beginning of the string being matched.  Otherwise
  it fails to match anything.  Thus, <code>`^foo'</code> matches a
  <code>`foo'</code> which occurs at the beginning of the string.
<P>
<DT><STRONG>`$'</STRONG>
<DD> is similar to <code>`^'</code> but matches only at the
  *end* of the string.  Thus, <code>`xx*$'</code> matches a string of one or
  more <code>`x'</code>'s at the end of the string.
<P>
<DT><STRONG>`%'</STRONG>
<DD>
  has two functions: it quotes the above special characters
(including <code>`%'</code>),
and it introduces additional special constructs.
<P>
Because <code>`%'</code> quotes special characters, <code>`%$'</code> is a
regular expression that
matches only <code>`$'</code>, and <code>`%['</code> is a regular expression
that matches only <code>`['</code>, and so on.
<P>
For the most part, <code>`%'</code> followed by any character matches
only that character.  However, there are several exceptions:
characters that, when
preceded by <code>`%'</code>, are special constructs.  Such characters
are always ordinary when encountered on their own.
<P>
No new special characters will ever be defined.  All extensions to the
regular expression syntax are made by defining new two-character
constructs that begin with <code>`%'</code>.
<P>
<DT><STRONG>`%|'</STRONG>
<DD>
  specifies an alternative.  Two regular expressions A and B
with <code>`%|'</code> in
between form an expression that matches anything that either A or B
will match.
<P>
Thus, <code>`foo%|bar'</code> matches either <code>`foo'</code> or
<code>`bar'</code> but no other string.
<P>
<code>`%|'</code> applies to the largest possible surrounding
expressions.  Only a
surrounding <code>`%( ... %)'</code> grouping can limit the grouping
power of <code>`%|'</code>.
<P>
Full backtracking capability exists for when multiple
<code>`%|'</code>'s are used.
<P>
<DT><STRONG>grouping:</STRONG>
<DD><code>`\%( ... \%)'</code><BR> 
  is a grouping construct that serves three purposes:
<P>
  1. To enclose a set of <code>`%|'</code> alternatives for other
  operations.  Thus,
<code>`%(foo%|bar%)x'</code> matches either <code>`foox'</code> or
<code>`barx'</code>.
<P>
2. To enclose a complicated expression for a following <code>`*'</code>,
<code>`+'</code>, or <code>`?'</code>
to operate on.  Thus, <code>`ba%(na%)*'</code> matches
<code>`bananana'</code>, etc., with any number of <code>`na'</code>'s, including
none.
<P>
3. To mark a matched substring for future reference.
<P>
This last application is not a consequence of the idea of a
parenthetical grouping; it is a separate feature that happens to be
assigned as a second
meaning to the same <code>`%( ... %)'</code> construct because there is
no conflict in practice between the two meanings.  Here is an
explanation of this feature:
<P>
<DT><STRONG>reference:</STRONG>
<DD><code>`%DIGIT'</code><BR> 
After the end of a <code>`%( ... %)'</code> construct, the matcher
remembers the beginning and end of the text matched by that construct.
Then, later on
in the regular expression, you can use <code>`%'</code> followed by
DIGIT to mean
&quot;match the same text matched by the DIGIT'+th <code>`%( ... %)'</code>
construct in the
pattern.&quot;  The <code>`%( ... %)'</code> constructs are numbered in the
order that their
<code>`%('</code>'s appear in the pattern.
<P>
The strings matching the first nine <code>`%( ... %)'</code> constructs
appearing in a regular expression are assigned numbers 1 through 9 in
order of their
beginnings.  <code>`%1'</code> through <code>`%9'</code> may be used to refer
to the text matched by
the corresponding <code>`%( ... %)'</code> construct.
<P>
For example, <code>`%(.*%)%1'</code> matches any string that is
composed of two
identical halves.  The <code>`%(.*%)'</code> matches the first half,
which may be
anything, but the <code>`%1'</code> that follows must match the same
exact text.
<P>
Let's look at an example from Ken's Bot:
<SMALL CLASS=SMALL><PRE>   1   your %(.*%)
           my %1? Why do you wish to know?
           I would rather not discuss my '%1' if it's allright with you...
           Tell me yours first!
   7   %(%w*%) is %(.*%)
            Suppose %1 were not %2? What then?
            What is so %2 about %1?
            %1? how so?</PRE></SMALL>
The first element in each pattern is matched against the input and
the other elements are possible replies using the matched pattern.
<P>
<DT><STRONG>`%b'</STRONG>
<DD>
  matches the empty string, but only if it is at the beginning or end
  of a
word.  Thus, <code>`%bfoo%b'</code> matches any occurrence of
<code>`foo'</code> as a separate word.
<code>`%bball%(s%|%)%b'</code> matches <code>`ball'</code> or <code>`balls'</code>
as a separate word.
<P>
For the purposes of this construct and the five that follow, a word is
defined to be a sequence of letters and/or digits.
<P>
<DT><STRONG>`%B'</STRONG>
<DD>
  matches the empty string, provided it is *not* at the beginning or
  end of a word.
<P>
<DT><STRONG>`%&lt;'</STRONG>
<DD>
  matches the empty string, but only if it is at the beginning of a
  word.
<P>
<DT><STRONG>`%&gt;'</STRONG>
<DD>
  matches the empty string, but only if it is at the end of a word.
<P>
<DT><STRONG>`%w'</STRONG>
<DD>
  matches any word-constituent character (i.e., any letter or digit).
<P>
<DT><STRONG>`%W'</STRONG>
<DD>
  matches any character that is not a word constituent.
<P>
 </DL>
<P>
You can look at a short <A NAME="tex2html113" HREF="http://tecfa.unige.ch/tecfa/tecfa-teaching/staf14/files/regexp.html">text in french</A> that summarizes regular
expressions.
<P>
A note about regexps in emacs and perl. Please remember that the ``<code>%</code>''
is replaced by the ``<code>\</code>'' !
<P>
Replacing complex patterns in emacs is a good way to learn regular expressions.
Take a random text and start playing around. Example:
<SMALL CLASS=SMALL><PRE>M-x query-replace-regexp
    lib\(.*\)graphics/&lt;RET&gt;graphics\1&lt;RET&gt;</PRE></SMALL>
would replace a pattern like this:
<SMALL CLASS=SMALL><PRE>/unige/tex2e/local/lib/texmf/tex/latex2e/graphics/graphicx.sty
     into
/unige/tex2e/local/graphics/texmf/tex/latex2e//graphicx.sty</PRE></SMALL>
Note that <code>ctrl_</code> will undo changes so you can retry and also
that <code>Meta-P</code> and <code>Meta-N</code> will allow to edit previous
arguments in the <code>M-x query-replace-regexp</code> dialog.
<P>
<HR><A NAME="tex2html1460" HREF="node63.html"><IMG WIDTH=37 HEIGHT=24 ALIGN=BOTTOM ALT="next" SRC="http://tecfa.unige.ch/gif/tex2html//next_motif.gif"></A> <A NAME="tex2html1458" HREF="node61.html"><IMG WIDTH=26 HEIGHT=24 ALIGN=BOTTOM ALT="up" SRC="http://tecfa.unige.ch/gif/tex2html//up_motif.gif"></A> <A NAME="tex2html1452" HREF="node61.html"><IMG WIDTH=63 HEIGHT=24 ALIGN=BOTTOM ALT="previous" SRC="http://tecfa.unige.ch/gif/tex2html//previous_motif.gif"></A> <A NAME="tex2html1462" HREF="node1.html"><IMG WIDTH=65 HEIGHT=24 ALIGN=BOTTOM ALT="contents" SRC="http://tecfa.unige.ch/gif/tex2html//contents_motif.gif"></A> <A NAME="tex2html1463" HREF="node167.html"><IMG WIDTH=43 HEIGHT=24 ALIGN=BOTTOM ALT="index" SRC="http://tecfa.unige.ch/gif/tex2html//index_motif.gif"></A> <A NAME="tex2html2" HREF="http://tecfa.unige.ch//moo/book2/tm2.html"> <IMG  ALIGN=BOTTOM ALT="external" SRC="http://tecfa.unige.ch/ico/navi/tex2html/top.gif"  > </A><BR>
<B> Next:</B> <A NAME="tex2html1461" HREF="node63.html">Conceptual Issues</A>
<B>Up:</B> <A NAME="tex2html1459" HREF="node61.html">6.3 Ken's Turing Robot</A>
<B> Previous:</B> <A NAME="tex2html1453" HREF="node61.html">6.3 Ken's Turing Robot</A>
<P><ADDRESS>
<I>Daniel K. Schneider <BR>
Thu Apr 17 12:43:52 MET DST 1997</I>
</ADDRESS>
</BODY>
</HTML>
